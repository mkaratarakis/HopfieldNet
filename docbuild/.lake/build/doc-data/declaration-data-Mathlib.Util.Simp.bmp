{"name":"Mathlib.Util.Simp","instances":[],"imports":["Init","Lean.Meta.Tactic.Simp.Types","Mathlib.Init","Qq"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Util/Simp.lean#L20-L26","name":"Lean.Meta.Simp.Methods.dischargeQ?","line":20,"kind":"def","docLink":"./Mathlib/Util/Simp.html#Lean.Meta.Simp.Methods.dischargeQ?","doc":"`Qq` version of `Lean.Meta.Simp.Methods.discharge?`, which avoids having to use `~q` matching\non the proof expression returned by `discharge?`\n\n`dischargeQ? (a : Q(Prop))` attempts to prove `a` using the discharger, returning\n`some (pf : Q(a))` if a proof is found and `none` otherwise. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Util/Simp.html#Lean.Meta.Simp.Methods.dischargeQ?\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Simp</span>.<span class=\"name\">Methods</span>.<span class=\"name\">dischargeQ?</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">M</span> : <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Methods\">Methods</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Prop</a>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.SimpM\">SimpM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">Q(<span class=\"fn\">«$a»</span>)</span>)</span></span></div></div>"}]}