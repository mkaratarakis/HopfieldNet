{"name":"Mathlib.Tactic.Linarith.Oracle.FourierMotzkin","instances":[{"typeNames":["Std.TreeSet"],"name":"Std.TreeSet.instUnion_mathlib","className":"Union"},{"typeNames":["Std.TreeSet"],"name":"Std.TreeSet.instSDiff_mathlib","className":"SDiff"},{"typeNames":["Linarith.CompSource"],"name":"Linarith.instInhabitedCompSource","className":"Inhabited"},{"typeNames":["Linarith.CompSource"],"name":"Linarith.instToFormatCompSource","className":"Std.ToFormat"},{"typeNames":["Linarith.PComp"],"name":"Linarith.instToFormatPComp","className":"Std.ToFormat"},{"typeNames":["Linarith.PComp"],"name":"Linarith.instToStringPComp","className":"ToString"}],"imports":["Init","Mathlib.Std.Data.HashMap","Batteries.Lean.HashMap","Batteries.Data.RBMap.Basic","Mathlib.Tactic.Linarith.Datatypes"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L355-L363","name":"Linarith.CertificateOracle.fourierMotzkin","line":355,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.CertificateOracle.fourierMotzkin","doc":"An oracle that uses Fourier-Motzkin elimination. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.CertificateOracle.fourierMotzkin\"><span class=\"name\">Linarith</span>.<span class=\"name\">CertificateOracle</span>.<span class=\"name\">fourierMotzkin</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.CertificateOracle\">CertificateOracle</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L348-L353","name":"Linarith.mkLinarithData","line":348,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.mkLinarithData","doc":"`mkLinarithData hyps vars` takes a list of hypotheses and the largest variable present in\nthose hypotheses. It produces an initial state for the elimination monad.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.mkLinarithData\"><span class=\"name\">Linarith</span>.<span class=\"name\">mkLinarithData</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hyps</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Comp\">Comp</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">maxVar</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.LinarithData\">LinarithData</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L340-L346","name":"Linarith.elimAllVarsM","line":340,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.elimAllVarsM","doc":"`elimAllVarsM` eliminates all variables from the linarith state, leaving it with a set of\nground comparisons. If this succeeds without exception, the original `linarith` state is consistent.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.elimAllVarsM\"><span class=\"name\">Linarith</span>.<span class=\"name\">elimAllVarsM</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.LinarithM\">LinarithM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L325-L338","name":"Linarith.elimVarM","line":325,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.elimVarM","doc":"`elimVarM a` performs one round of Fourier-Motzkin elimination, eliminating the variable `a`\nfrom the `linarith` state.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.elimVarM\"><span class=\"name\">Linarith</span>.<span class=\"name\">elimVarM</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.LinarithM\">LinarithM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L309-L323","name":"Linarith.splitSetByVarSign","line":309,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.splitSetByVarSign","doc":"`splitSetByVarSign a comps` partitions the set `comps` into three parts.\n* `pos` contains the elements of `comps` in which `a` has a positive coefficient.\n* `neg` contains the elements of `comps` in which `a` has a negative coefficient.\n* `notPresent` contains the elements of `comps` in which `a` has coefficient 0.\n\nReturns `(pos, neg, notPresent)`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.splitSetByVarSign\"><span class=\"name\">Linarith</span>.<span class=\"name\">splitSetByVarSign</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">comps</span> : <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PCompSet\">PCompSet</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PCompSet\">PCompSet</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PCompSet\">PCompSet</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PCompSet\">PCompSet</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L301-L307","name":"Linarith.update","line":301,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.update","doc":"Updates the current state with a new max variable and comparisons,\nand calls `validate` to check for a contradiction.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.update\"><span class=\"name\">Linarith</span>.<span class=\"name\">update</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">maxVar</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">comps</span> : <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PCompSet\">PCompSet</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.LinarithM\">LinarithM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L295-L299","name":"Linarith.validate","line":295,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.validate","doc":"Throws an exception if a contradictory `PComp` is contained in the current state. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.validate\"><span class=\"name\">Linarith</span>.<span class=\"name\">validate</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.LinarithM\">LinarithM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L291-L293","name":"Linarith.getPCompSet","line":291,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.getPCompSet","doc":"Return the current comparison set. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.getPCompSet\"><span class=\"name\">Linarith</span>.<span class=\"name\">getPCompSet</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.LinarithM\">LinarithM</a> <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PCompSet\">PCompSet</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L287-L289","name":"Linarith.getMaxVar","line":287,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.getMaxVar","doc":"Returns the current max variable. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.getMaxVar\"><span class=\"name\">Linarith</span>.<span class=\"name\">getMaxVar</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.LinarithM\">LinarithM</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L280-L285","name":"Linarith.LinarithM","line":280,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.LinarithM","doc":"The linarith monad extends an exceptional monad with a `LinarithData` state.\nAn exception produces a contradictory `PComp`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.LinarithM\"><span class=\"name\">Linarith</span>.<span class=\"name\">LinarithM</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> → <a href=\"./foundational_types.html\">Type</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L278-L278","name":"Linarith.LinarithData.comps","line":278,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.LinarithData.comps","doc":"The set of comparisons. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.LinarithData.comps\"><span class=\"name\">Linarith</span>.<span class=\"name\">LinarithData</span>.<span class=\"name\">comps</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.LinarithData\">LinarithData</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PCompSet\">PCompSet</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L276-L276","name":"Linarith.LinarithData.maxVar","line":276,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.LinarithData.maxVar","doc":"The largest variable index that has not been (officially) eliminated. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.LinarithData.maxVar\"><span class=\"name\">Linarith</span>.<span class=\"name\">LinarithData</span>.<span class=\"name\">maxVar</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.LinarithData\">LinarithData</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L274-L274","name":"Linarith.LinarithData.mk","line":274,"kind":"ctor","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.LinarithData.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.LinarithData.mk\"><span class=\"name\">Linarith</span>.<span class=\"name\">LinarithData</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">maxVar</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">comps</span> : <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PCompSet\">PCompSet</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.LinarithData\">LinarithData</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L266-L278","name":"Linarith.LinarithData","line":266,"kind":"structure","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.LinarithData","doc":"The state for the elimination monad.\n* `maxVar`: the largest variable index that has not been eliminated.\n* `comps`: a set of comparisons\n\nThe elimination procedure proceeds by eliminating variable `v` from `comps` progressively\nin decreasing order.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.LinarithData\"><span class=\"name\">Linarith</span>.<span class=\"name\">LinarithData</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L256-L264","name":"Linarith.elimWithSet","line":256,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.elimWithSet","doc":"`elimWithSet a p comps` collects the result of calling `pelimVar p p' a`\nfor every `p' ∈ comps`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.elimWithSet\"><span class=\"name\">Linarith</span>.<span class=\"name\">elimWithSet</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp\">PComp</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">comps</span> : <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PCompSet\">PCompSet</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PCompSet\">PCompSet</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L251-L254","name":"Linarith.PComp.isContr","line":251,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp.isContr","doc":"A `PComp` represents a contradiction if its `Comp` field represents a contradiction.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp.isContr\"><span class=\"name\">Linarith</span>.<span class=\"name\">PComp</span>.<span class=\"name\">isContr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp\">PComp</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L242-L249","name":"Linarith.pelimVar","line":242,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.pelimVar","doc":"`pelimVar p1 p2` calls `elimVar` on the `Comp` components of `p1` and `p2`.\nIf this returns `v1` and `v2`, it creates a new `PComp` equal to `v1*p1 + v2*p2`,\nand tracks this in the `CompSource`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.pelimVar\"><span class=\"name\">Linarith</span>.<span class=\"name\">pelimVar</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p1 </span><span class=\"fn\">p2</span> : <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp\">PComp</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp\">PComp</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L232-L240","name":"Linarith.elimVar","line":232,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.elimVar","doc":"If `c1` and `c2` both contain variable `a` with opposite coefficients,\nproduces `v1` and `v2` such that `a` has been cancelled in `v1*c1 + v2*c2`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.elimVar\"><span class=\"name\">Linarith</span>.<span class=\"name\">elimVar</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">c1 </span><span class=\"fn\">c2</span> : <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Comp\">Comp</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> (<a href=\"./Init/Prelude.html#Nat\">ℕ</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L227-L228","name":"Linarith.PCompSet","line":227,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PCompSet","doc":"A collection of comparisons. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PCompSet\"><span class=\"name\">Linarith</span>.<span class=\"name\">PCompSet</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L224-L225","name":"Linarith.instToStringPComp","line":224,"kind":"instance","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.instToStringPComp","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.instToStringPComp\"><span class=\"name\">Linarith</span>.<span class=\"name\">instToStringPComp</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/ToString/Basic.html#ToString\">ToString</a> <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp\">PComp</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L221-L222","name":"Linarith.instToFormatPComp","line":221,"kind":"instance","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.instToFormatPComp","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.instToFormatPComp\"><span class=\"name\">Linarith</span>.<span class=\"name\">instToFormatPComp</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Format/Basic.html#Std.ToFormat\">Std.ToFormat</a> <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp\">PComp</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L207-L219","name":"Linarith.PComp.assump","line":207,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp.assump","doc":"`PComp.assump c n` creates a `PComp` whose comparison is `c` and whose source is\n`CompSource.assump n`, that is, `c` is derived from the `n`th hypothesis.\nThe history is the singleton set `{n}`.\nNo variables have been eliminated (effectively or implicitly).\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp.assump\"><span class=\"name\">Linarith</span>.<span class=\"name\">PComp</span>.<span class=\"name\">assump</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">c</span> : <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Comp\">Comp</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp\">PComp</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L179-L205","name":"Linarith.PComp.add","line":179,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp.add","doc":"`PComp.add c1 c2 elimVar` creates the result of summing the linear comparisons `c1` and `c2`,\nduring the process of eliminating the variable `elimVar`.\nThe computation assumes, but does not enforce, that `elimVar` appears in both `c1` and `c2`\nand does not appear in the sum.\nComputing the sum of the two comparisons is easy; the complicated details lie in tracking the\nadditional fields of `PComp`.\n* The historical set `pcomp.history` of `c1 + c2` is the union of the two historical sets.\n* `vars` is the union of `c1.vars` and `c2.vars`.\n* The effectively eliminated variables of `c1 + c2` are the union of the two effective sets,\n  with `elim_var` inserted.\n* The implicitly eliminated variables of `c1 + c2` are those that appear in\n  `vars` but not `c.vars` or `effective`.\n(Note that the description of the implicitly eliminated variables of `c1 + c2` in the algorithm\ndescribed in Section 6 of https://doi.org/10.1016/B978-0-444-88771-9.50019-2 seems to be wrong:\nthat says it should be `(c1.implicit.union c2.implicit).sdiff explicit`.\nSince the implicitly eliminated sets start off empty for the assumption,\nthis formula would leave them always empty.)\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp.add\"><span class=\"name\">Linarith</span>.<span class=\"name\">PComp</span>.<span class=\"name\">add</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">c1 </span><span class=\"fn\">c2</span> : <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp\">PComp</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">elimVar</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp\">PComp</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L175-L177","name":"Linarith.PComp.scale","line":175,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp.scale","doc":"`PComp.scale c n` scales the coefficients of `c` by `n` and notes this in the `CompSource`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp.scale\"><span class=\"name\">Linarith</span>.<span class=\"name\">PComp</span>.<span class=\"name\">scale</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">c</span> : <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp\">PComp</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp\">PComp</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L169-L173","name":"Linarith.PComp.cmp","line":169,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp.cmp","doc":"The `src : CompSource` field is ignored when comparing `PComp`s. Two `PComp`s proving the same\ncomparison, with different sources, are considered equivalent.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp.cmp\"><span class=\"name\">Linarith</span>.<span class=\"name\">PComp</span>.<span class=\"name\">cmp</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p1 </span><span class=\"fn\">p2</span> : <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp\">PComp</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/Ord.html#Ordering\">Ordering</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L145-L167","name":"Linarith.PComp.maybeMinimal","line":145,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp.maybeMinimal","doc":"Any comparison whose history is not minimal is redundant,\nand need not be included in the new set of comparisons.\n`elimedGE : ℕ` is a natural number such that all variables with index ≥ `elimedGE` have been\nremoved from the system.\n\nThis test is an overapproximation to minimality. It gives necessary but not sufficient conditions.\nIf the history of `c` is minimal, then `c.maybeMinimal` is true,\nbut `c.maybeMinimal` may also be true for some `c` with non-minimal history.\nThus, if `c.maybeMinimal` is false, `c` is known not to be minimal and must be redundant.\nSee https://doi.org/10.1016/B978-0-444-88771-9.50019-2 (Theorem 13).\nThe condition described there considers only implicitly eliminated variables that have been\nofficially eliminated from the system. This is not the case for every implicitly eliminated\nvariable. Consider eliminating `z` from `{x + y + z < 0, x - y - z < 0}`. The result is the set\n`{2*x < 0}`; `y` is implicitly but not officially eliminated.\n\nThis implementation of Fourier-Motzkin elimination processes variables in decreasing order of\nindices. Immediately after a step that eliminates variable `k`, variable `k'` has been eliminated\niff `k' ≥ k`. Thus we can compute the intersection of officially and implicitly eliminated variables\nby taking the set of implicitly eliminated variables with indices ≥ `elimedGE`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp.maybeMinimal\"><span class=\"name\">Linarith</span>.<span class=\"name\">PComp</span>.<span class=\"name\">maybeMinimal</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">c</span> : <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp\">PComp</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">elimedGE</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L143-L143","name":"Linarith.PComp.vars","line":143,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp.vars","doc":"The union of all variables appearing in those original assumptions\nwhich appear in the `history` set. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp.vars\"><span class=\"name\">Linarith</span>.<span class=\"name\">PComp</span>.<span class=\"name\">vars</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp\">PComp</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Std/Data/TreeSet/Basic.html#Std.TreeSet\">Std.TreeSet</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a> <a href=\"./Init/Data/Ord.html#Ord.compare\">compare</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L140-L140","name":"Linarith.PComp.implicit","line":140,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp.implicit","doc":"The variables which have been *implicitly eliminated*.\nThese are variables that appear in the historical set,\ndo not appear in `c` itself, and are not in `effective. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp.implicit\"><span class=\"name\">Linarith</span>.<span class=\"name\">PComp</span>.<span class=\"name\">implicit</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp\">PComp</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Std/Data/TreeSet/Basic.html#Std.TreeSet\">Std.TreeSet</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a> <a href=\"./Init/Data/Ord.html#Ord.compare\">compare</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L136-L136","name":"Linarith.PComp.effective","line":136,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp.effective","doc":"The variables which have been *effectively eliminated*,\ni.e. by running the elimination algorithm on that variable. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp.effective\"><span class=\"name\">Linarith</span>.<span class=\"name\">PComp</span>.<span class=\"name\">effective</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp\">PComp</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Std/Data/TreeSet/Basic.html#Std.TreeSet\">Std.TreeSet</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a> <a href=\"./Init/Data/Ord.html#Ord.compare\">compare</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L133-L133","name":"Linarith.PComp.history","line":133,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp.history","doc":"The set of original assumptions which have been used in constructing this comparison. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp.history\"><span class=\"name\">Linarith</span>.<span class=\"name\">PComp</span>.<span class=\"name\">history</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp\">PComp</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Std/Data/TreeSet/Basic.html#Std.TreeSet\">Std.TreeSet</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a> <a href=\"./Init/Data/Ord.html#Ord.compare\">compare</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L131-L131","name":"Linarith.PComp.src","line":131,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp.src","doc":"We track how the comparison was constructed by adding and scaling previous comparisons,\nback to the original assumptions. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp.src\"><span class=\"name\">Linarith</span>.<span class=\"name\">PComp</span>.<span class=\"name\">src</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp\">PComp</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.CompSource\">CompSource</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L128-L128","name":"Linarith.PComp.c","line":128,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp.c","doc":"The comparison `Σ cᵢ*xᵢ R 0`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp.c\"><span class=\"name\">Linarith</span>.<span class=\"name\">PComp</span>.<span class=\"name\">c</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp\">PComp</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Comp\">Comp</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L126-L126","name":"Linarith.PComp.mk","line":126,"kind":"ctor","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp.mk\"><span class=\"name\">Linarith</span>.<span class=\"name\">PComp</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">c</span> : <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Comp\">Comp</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">src</span> : <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.CompSource\">CompSource</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">history </span><span class=\"fn\">effective </span><span class=\"fn\">implicit </span><span class=\"fn\">vars</span> : <span class=\"fn\"><a href=\"./Std/Data/TreeSet/Basic.html#Std.TreeSet\">Std.TreeSet</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a> <a href=\"./Init/Data/Ord.html#Ord.compare\">compare</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp\">PComp</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L103-L143","name":"Linarith.PComp","line":103,"kind":"structure","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp","doc":"A `PComp` stores a linear comparison `Σ cᵢ*xᵢ R 0`,\nalong with information about how this comparison was derived.\nThe original expressions fed into `linarith` are each assigned a unique natural number label.\nThe *historical set* `PComp.history` stores the labels of expressions\nthat were used in deriving the current `PComp`.\nVariables are also indexed by natural numbers. The sets `PComp.effective`, `PComp.implicit`,\nand `PComp.vars` contain variable indices.\n* `PComp.vars` contains the variables that appear in any inequality in the historical set.\n* `PComp.effective` contains the variables that have been effectively eliminated from `PComp`.\n  A variable `n` is said to be *effectively eliminated* in `p : PComp` if the elimination of `n`\n  produced at least one of the ancestors of `p` (or `p` itself).\n* `PComp.implicit` contains the variables that have been implicitly eliminated from `PComp`.\n  A variable `n` is said to be *implicitly eliminated* in `p` if it satisfies the following\n  properties:\n  - `n` appears in some inequality in the historical set (i.e. in `p.vars`).\n  - `n` does not appear in `p.c.vars` (i.e. it has been eliminated).\n  - `n` was not effectively eliminated.\n\nWe track these sets in order to compute whether the history of a `PComp` is *minimal*.\nChecking this directly is expensive, but effective approximations can be defined in terms of these\nsets. During the variable elimination process, a `PComp` with non-minimal history can be discarded.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.PComp\"><span class=\"name\">Linarith</span>.<span class=\"name\">PComp</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L100-L101","name":"Linarith.instToFormatCompSource","line":100,"kind":"instance","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.instToFormatCompSource","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.instToFormatCompSource\"><span class=\"name\">Linarith</span>.<span class=\"name\">instToFormatCompSource</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Format/Basic.html#Std.ToFormat\">Std.ToFormat</a> <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.CompSource\">CompSource</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L94-L98","name":"Linarith.CompSource.toString","line":94,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.CompSource.toString","doc":"Formats a `CompSource` for printing. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.CompSource.toString\"><span class=\"name\">Linarith</span>.<span class=\"name\">CompSource</span>.<span class=\"name\">toString</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.CompSource\">CompSource</a> → <a href=\"./Init/Prelude.html#String\">String</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L80-L92","name":"Linarith.CompSource.flatten","line":80,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.CompSource.flatten","doc":"Given a `CompSource` `cs`, `cs.flatten` maps an assumption index\nto the number of copies of that assumption that appear in the history of `cs`.\n\nFor example, suppose `cs` is produced by scaling assumption 2 by 5,\nand adding to that the sum of assumptions 1 and 2.\n`cs.flatten` maps `1 ↦ 1, 2 ↦ 6`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.CompSource.flatten\"><span class=\"name\">Linarith</span>.<span class=\"name\">CompSource</span>.<span class=\"name\">flatten</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.CompSource\">CompSource</a> → <span class=\"fn\"><a href=\"./Std/Data/HashMap/Basic.html#Std.HashMap\">Std.HashMap</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L78-L78","name":"Linarith.instInhabitedCompSource","line":78,"kind":"instance","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.instInhabitedCompSource","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.instInhabitedCompSource\"><span class=\"name\">Linarith</span>.<span class=\"name\">instInhabitedCompSource</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.CompSource\">CompSource</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L77-L77","name":"Linarith.CompSource.scale","line":77,"kind":"ctor","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.CompSource.scale","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.CompSource.scale\"><span class=\"name\">Linarith</span>.<span class=\"name\">CompSource</span>.<span class=\"name\">scale</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.CompSource\">CompSource</a> → <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.CompSource\">CompSource</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L76-L76","name":"Linarith.CompSource.add","line":76,"kind":"ctor","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.CompSource.add","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.CompSource.add\"><span class=\"name\">Linarith</span>.<span class=\"name\">CompSource</span>.<span class=\"name\">add</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.CompSource\">CompSource</a> → <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.CompSource\">CompSource</a> → <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.CompSource\">CompSource</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L75-L75","name":"Linarith.CompSource.assump","line":75,"kind":"ctor","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.CompSource.assump","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.CompSource.assump\"><span class=\"name\">Linarith</span>.<span class=\"name\">CompSource</span>.<span class=\"name\">assump</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a> → <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.CompSource\">CompSource</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L68-L78","name":"Linarith.CompSource","line":68,"kind":"inductive","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.CompSource","doc":"`CompSource` tracks the source of a comparison.\nThe atomic source of a comparison is an assumption, indexed by a natural number.\nTwo comparisons can be added to produce a new comparison,\nand one comparison can be scaled by a natural number to produce a new comparison.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Linarith.CompSource\"><span class=\"name\">Linarith</span>.<span class=\"name\">CompSource</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L55-L55","name":"Std.TreeSet.instSDiff_mathlib","line":55,"kind":"instance","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Std.TreeSet.instSDiff_mathlib","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Std.TreeSet.instSDiff_mathlib\"><span class=\"name\">Std</span>.<span class=\"name\">TreeSet</span>.<span class=\"name\">instSDiff_mathlib</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">cmp</span> : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">α</span> → <a href=\"./Init/Data/Ord.html#Ordering\">Ordering</a></span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Core.html#SDiff\">SDiff</a> <span class=\"fn\">(<a href=\"./Std/Data/TreeSet/Basic.html#Std.TreeSet\">TreeSet</a> <span class=\"fn\">α</span> <span class=\"fn\">cmp</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L50-L53","name":"Std.TreeSet.sdiff","line":50,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Std.TreeSet.sdiff","doc":"`O(n₁ * (log n₁ + log n₂))`. Constructs the set of all elements of `t₁` that are not in `t₂`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Std.TreeSet.sdiff\"><span class=\"name\">Std</span>.<span class=\"name\">TreeSet</span>.<span class=\"name\">sdiff</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">cmp</span> : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">α</span> → <a href=\"./Init/Data/Ord.html#Ordering\">Ordering</a></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">t₁ </span><span class=\"fn\">t₂</span> : <span class=\"fn\"><a href=\"./Std/Data/TreeSet/Basic.html#Std.TreeSet\">TreeSet</a> <span class=\"fn\">α</span> <span class=\"fn\">cmp</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Std/Data/TreeSet/Basic.html#Std.TreeSet\">TreeSet</a> <span class=\"fn\">α</span> <span class=\"fn\">cmp</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L48-L48","name":"Std.TreeSet.instUnion_mathlib","line":48,"kind":"instance","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Std.TreeSet.instUnion_mathlib","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Std.TreeSet.instUnion_mathlib\"><span class=\"name\">Std</span>.<span class=\"name\">TreeSet</span>.<span class=\"name\">instUnion_mathlib</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">cmp</span> : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">α</span> → <a href=\"./Init/Data/Ord.html#Ordering\">Ordering</a></span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Core.html#Union\">Union</a> <span class=\"fn\">(<a href=\"./Std/Data/TreeSet/Basic.html#Std.TreeSet\">TreeSet</a> <span class=\"fn\">α</span> <span class=\"fn\">cmp</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L41-L46","name":"Std.TreeSet.union","line":41,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Std.TreeSet.union","doc":"`O(n₂ * log (n₁ + n₂))`. Merges the maps `t₁` and `t₂`.\nIf equal keys exist in both, the key from `t₂` is preferred.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Std.TreeSet.union\"><span class=\"name\">Std</span>.<span class=\"name\">TreeSet</span>.<span class=\"name\">union</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">cmp</span> : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">α</span> → <a href=\"./Init/Data/Ord.html#Ordering\">Ordering</a></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">t₁ </span><span class=\"fn\">t₂</span> : <span class=\"fn\"><a href=\"./Std/Data/TreeSet/Basic.html#Std.TreeSet\">TreeSet</a> <span class=\"fn\">α</span> <span class=\"fn\">cmp</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Std/Data/TreeSet/Basic.html#Std.TreeSet\">TreeSet</a> <span class=\"fn\">α</span> <span class=\"fn\">cmp</span></span></div></div>"}]}