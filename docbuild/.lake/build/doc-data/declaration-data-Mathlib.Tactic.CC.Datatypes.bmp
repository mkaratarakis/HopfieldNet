{"name":"Mathlib.Tactic.CC.Datatypes","instances":[{"typeNames":["Mathlib.Tactic.CC.CCCongrTheoremKey"],"name":"Mathlib.Tactic.CC.instBEqCCCongrTheoremKey","className":"BEq"},{"typeNames":["Mathlib.Tactic.CC.CCCongrTheoremKey"],"name":"Mathlib.Tactic.CC.instHashableCCCongrTheoremKey","className":"Hashable"},{"typeNames":["Mathlib.Tactic.CC.CCConfig"],"name":"Mathlib.Tactic.CC.instInhabitedCCConfig","className":"Inhabited"},{"typeNames":["Mathlib.Tactic.CC.ACApps"],"name":"Mathlib.Tactic.CC.instInhabitedACApps","className":"Inhabited"},{"typeNames":["Mathlib.Tactic.CC.ACApps"],"name":"Mathlib.Tactic.CC.instBEqACApps","className":"BEq"},{"typeNames":["Lean.Expr","Mathlib.Tactic.CC.ACApps"],"name":"Mathlib.Tactic.CC.instCoeExprACApps","className":"Coe"},{"typeNames":["Mathlib.Tactic.CC.DelayedExpr"],"name":"Mathlib.Tactic.CC.instInhabitedDelayedExpr","className":"Inhabited"},{"typeNames":["Lean.Expr","Mathlib.Tactic.CC.DelayedExpr"],"name":"Mathlib.Tactic.CC.instCoeExprDelayedExpr","className":"Coe"},{"typeNames":["Mathlib.Tactic.CC.EntryExpr"],"name":"Mathlib.Tactic.CC.instInhabitedEntryExpr","className":"Inhabited"},{"typeNames":["Mathlib.Tactic.CC.EntryExpr"],"name":"Mathlib.Tactic.CC.instToMessageDataEntryExpr","className":"Lean.ToMessageData"},{"typeNames":["Lean.Expr","Mathlib.Tactic.CC.EntryExpr"],"name":"Mathlib.Tactic.CC.instCoeExprEntryExpr","className":"Coe"},{"typeNames":["Mathlib.Tactic.CC.Entry"],"name":"Mathlib.Tactic.CC.instInhabitedEntry","className":"Inhabited"},{"typeNames":["Mathlib.Tactic.CC.ACEntry"],"name":"Mathlib.Tactic.CC.instInhabitedACEntry","className":"Inhabited"},{"typeNames":["Mathlib.Tactic.CC.CongruencesKey"],"name":"Mathlib.Tactic.CC.instBEqCongruencesKey","className":"BEq"},{"typeNames":["Mathlib.Tactic.CC.CongruencesKey"],"name":"Mathlib.Tactic.CC.instHashableCongruencesKey","className":"Hashable"},{"typeNames":["Mathlib.Tactic.CC.SymmCongruencesKey"],"name":"Mathlib.Tactic.CC.instBEqSymmCongruencesKey","className":"BEq"},{"typeNames":["Mathlib.Tactic.CC.SymmCongruencesKey"],"name":"Mathlib.Tactic.CC.instHashableSymmCongruencesKey","className":"Hashable"},{"typeNames":["Mathlib.Tactic.CC.CCState"],"name":"Mathlib.Tactic.CC.instInhabitedCCState","className":"Inhabited"},{"typeNames":["Mathlib.Tactic.CC.CCStructure"],"name":"Mathlib.Tactic.CC.instInhabitedCCStructure","className":"Inhabited"}],"imports":["Init","Batteries.Classes.Order","Mathlib.Lean.Meta.Basic","Mathlib.Lean.Meta.CongrTheorems","Mathlib.Data.Ordering.Basic"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L692-L692","name":"Mathlib.Tactic.CC.instInhabitedCCStructure","line":692,"kind":"instance","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instInhabitedCCStructure","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instInhabitedCCStructure\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">instInhabitedCCStructure</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCStructure\">CCStructure</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L691-L691","name":"Mathlib.Tactic.CC.CCStructure.cache","line":691,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCStructure.cache","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCStructure.cache\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCStructure</span>.<span class=\"name\">cache</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCStructure\">CCStructure</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheoremCache\">CCCongrTheoremCache</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L690-L690","name":"Mathlib.Tactic.CC.CCStructure.phandler","line":690,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCStructure.phandler","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCStructure.phandler\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCStructure</span>.<span class=\"name\">phandler</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCStructure\">CCStructure</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCPropagationHandler\">CCPropagationHandler</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L689-L689","name":"Mathlib.Tactic.CC.CCStructure.normalizer","line":689,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCStructure.normalizer","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCStructure.normalizer\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCStructure</span>.<span class=\"name\">normalizer</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCStructure\">CCStructure</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCNormalizer\">CCNormalizer</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L688-L688","name":"Mathlib.Tactic.CC.CCStructure.acTodo","line":688,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCStructure.acTodo","doc":"AC-equalities that have been discovered but not processed. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCStructure.acTodo\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCStructure</span>.<span class=\"name\">acTodo</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCStructure\">CCStructure</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACTodoEntry\">ACTodoEntry</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L686-L686","name":"Mathlib.Tactic.CC.CCStructure.todo","line":686,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCStructure.todo","doc":"Equalities that have been discovered but not processed. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCStructure.todo\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCStructure</span>.<span class=\"name\">todo</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCStructure\">CCStructure</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.TodoEntry\">TodoEntry</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L684-L684","name":"Mathlib.Tactic.CC.CCStructure.mk","line":684,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCStructure.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCStructure.mk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCStructure</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">toCCState</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">todo</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.TodoEntry\">TodoEntry</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">acTodo</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACTodoEntry\">ACTodoEntry</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">normalizer</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCNormalizer\">CCNormalizer</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">phandler</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCPropagationHandler\">CCPropagationHandler</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">cache</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheoremCache\">CCCongrTheoremCache</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCStructure\">CCStructure</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L684-L692","name":"Mathlib.Tactic.CC.CCStructure.toCCState","line":684,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCStructure.toCCState","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCStructure.toCCState\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCStructure</span>.<span class=\"name\">toCCState</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCStructure\">CCStructure</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L681-L692","name":"Mathlib.Tactic.CC.CCStructure","line":681,"kind":"structure","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCStructure","doc":"`CCStructure` extends `CCState` (which records a set of facts derived by congruence closure)\nby recording which steps still need to be taken to solve the goal.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCStructure\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCStructure</span></a></span><span class=\"decl_extends\">extends</span> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">Mathlib.Tactic.CC.CCState</a><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L679-L679","name":"Mathlib.Tactic.CC.CCPropagationHandler.newAuxCCTerm","line":679,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCPropagationHandler.newAuxCCTerm","doc":"Congruence closure module invokes the following method when\na new auxiliary term is created during propagation. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCPropagationHandler.newAuxCCTerm\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCPropagationHandler</span>.<span class=\"name\">newAuxCCTerm</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCPropagationHandler\">CCPropagationHandler</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L676-L676","name":"Mathlib.Tactic.CC.CCPropagationHandler.propagated","line":676,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCPropagationHandler.propagated","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCPropagationHandler.propagated\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCPropagationHandler</span>.<span class=\"name\">propagated</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCPropagationHandler\">CCPropagationHandler</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L675-L675","name":"Mathlib.Tactic.CC.CCPropagationHandler.mk","line":675,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCPropagationHandler.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCPropagationHandler.mk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCPropagationHandler</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">propagated</span> : <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">newAuxCCTerm</span> : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCPropagationHandler\">CCPropagationHandler</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L675-L679","name":"Mathlib.Tactic.CC.CCPropagationHandler","line":675,"kind":"structure","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCPropagationHandler","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCPropagationHandler\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCPropagationHandler</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L671-L671","name":"Mathlib.Tactic.CC.CCNormalizer.normalize","line":671,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCNormalizer.normalize","doc":"The congruence closure module (optionally) uses a normalizer.\nThe idea is to use it (if available) to normalize auxiliary expressions\nproduced by internal propagation rules (e.g., subsingleton propagator). "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCNormalizer.normalize\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCNormalizer</span>.<span class=\"name\">normalize</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCNormalizer\">CCNormalizer</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L670-L670","name":"Mathlib.Tactic.CC.CCNormalizer.mk","line":670,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCNormalizer.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCNormalizer.mk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCNormalizer</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">normalize</span> : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCNormalizer\">CCNormalizer</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L667-L671","name":"Mathlib.Tactic.CC.CCNormalizer","line":667,"kind":"structure","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCNormalizer","doc":"The congruence closure module (optionally) uses a normalizer.\nThe idea is to use it (if available) to normalize auxiliary expressions\nproduced by internal propagation rules (e.g., subsingleton propagator). "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCNormalizer\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCNormalizer</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L662-L663","name":"Mathlib.Tactic.CC.CCState.ppAC","line":662,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.ppAC","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.ppAC\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">ppAC</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ccs</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Message.html#Lean.MessageData\">Lean.MessageData</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L657-L660","name":"Mathlib.Tactic.CC.CCState.ppACR","line":657,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.ppACR","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.ppACR\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">ppACR</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ccs</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Message.html#Lean.MessageData\">Lean.MessageData</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L651-L655","name":"Mathlib.Tactic.CC.CCState.ppACApps","line":651,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.ppACApps","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.ppACApps\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">ppACApps</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ccs</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">ACApps</a> → <a href=\"./Lean/Message.html#Lean.MessageData\">Lean.MessageData</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L645-L649","name":"Mathlib.Tactic.CC.CCState.ppACExpr","line":645,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.ppACExpr","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.ppACExpr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">ppACExpr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ccs</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Message.html#Lean.MessageData\">Lean.MessageData</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L641-L643","name":"Mathlib.Tactic.CC.CCState.ppACDecls","line":641,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.ppACDecls","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.ppACDecls\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">ppACDecls</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ccs</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Message.html#Lean.MessageData\">Lean.MessageData</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L636-L639","name":"Mathlib.Tactic.CC.CCState.ppACDecl","line":636,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.ppACDecl","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.ppACDecl\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">ppACDecl</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ccs</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Message.html#Lean.MessageData\">Lean.MessageData</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L632-L634","name":"Mathlib.Tactic.CC.CCState.ppParentOccs","line":632,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.ppParentOccs","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.ppParentOccs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">ppParentOccs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ccs</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Message.html#Lean.MessageData\">Lean.MessageData</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L624-L630","name":"Mathlib.Tactic.CC.CCState.ppParentOccsAux","line":624,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.ppParentOccsAux","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.ppParentOccsAux\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">ppParentOccsAux</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ccs</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Message.html#Lean.MessageData\">Lean.MessageData</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L615-L622","name":"Mathlib.Tactic.CC.CCState.ppEqcs","line":615,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.ppEqcs","doc":"Pretty print the entire cc graph.\nIf the `nonSingleton` argument is set to `true` then singleton equivalence classes will be\nomitted. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.ppEqcs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">ppEqcs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ccs</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">nonSingleton</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Message.html#Lean.MessageData\">Lean.MessageData</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L601-L613","name":"Mathlib.Tactic.CC.CCState.ppEqc","line":601,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.ppEqc","doc":"Pretty print the entry associated with the given expression. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.ppEqc\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">ppEqc</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ccs</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Message.html#Lean.MessageData\">Lean.MessageData</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L595-L597","name":"Mathlib.Tactic.CC.CCState.getVarWithLeastRHSOccs","line":595,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.getVarWithLeastRHSOccs","doc":"Search for the AC-variable (`Entry.acVar`) with the fewest occurrences in the RHS. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.getVarWithLeastRHSOccs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">getVarWithLeastRHSOccs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ccs</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">ACApps</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L591-L593","name":"Mathlib.Tactic.CC.CCState.getVarWithLeastLHSOccs","line":591,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.getVarWithLeastLHSOccs","doc":"Search for the AC-variable (`Entry.acVar`) with the fewest occurrences in the LHS. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.getVarWithLeastLHSOccs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">getVarWithLeastLHSOccs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ccs</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">ACApps</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L576-L589","name":"Mathlib.Tactic.CC.CCState.getVarWithLeastOccs","line":576,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.getVarWithLeastOccs","doc":"Search for the AC-variable (`Entry.acVar`) with the least occurrences in the state. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.getVarWithLeastOccs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">getVarWithLeastOccs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ccs</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">ACApps</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">inLHS</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L571-L574","name":"Mathlib.Tactic.CC.CCState.getNumROccs","line":571,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.getNumROccs","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.getNumROccs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">getNumROccs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ccs</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">inLHS</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L567-L569","name":"Mathlib.Tactic.CC.CCState.checkInvariant","line":567,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.checkInvariant","doc":"Check for integrity of the `CCState`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.checkInvariant\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">checkInvariant</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ccs</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L545-L565","name":"Mathlib.Tactic.CC.CCState.checkEqc","line":545,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.checkEqc","doc":"Check for integrity of the `CCState`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.checkEqc\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">checkEqc</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ccs</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L534-L543","name":"Mathlib.Tactic.CC.CCState.getRoots","line":534,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.getRoots","doc":"Append to `roots` all the roots of equivalence classes in `ccs`.\n\nIf `nonsingletonOnly` is true, we skip all the singleton equivalence classes. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.getRoots\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">getRoots</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ccs</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">roots</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">nonsingletonOnly</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L528-L532","name":"Mathlib.Tactic.CC.CCState.inSingletonEqc","line":528,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.inSingletonEqc","doc":"Is the expression in an equivalence class with only one element (namely, itself)? "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.inSingletonEqc\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">inSingletonEqc</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ccs</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L517-L526","name":"Mathlib.Tactic.CC.CCState.mt","line":517,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.mt","doc":"\"Modification Time\". The field `mt` is used to implement the mod-time optimization introduced by the\nSimplify theorem prover. The basic idea is to introduce a counter `gmt` that records the number of\nheuristic instantiation that have occurred in the current branch. It is incremented after each round\nof heuristic instantiation. The field `mt` records the last time any proper descendant of this\nentry was involved in a merge. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.mt\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">mt</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ccs</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L511-L515","name":"Mathlib.Tactic.CC.CCState.isCgRoot","line":511,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.isCgRoot","doc":"Check if `e` is the root of the congruence class. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.isCgRoot\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">isCgRoot</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ccs</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L504-L509","name":"Mathlib.Tactic.CC.CCState.next","line":504,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.next","doc":"Get the next element in the equivalence class.\nNote that if the given `Expr` `e` is not in the graph then it will just return `e`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.next\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">next</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ccs</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L498-L502","name":"Mathlib.Tactic.CC.CCState.root","line":498,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.root","doc":"Get the root representative of the given expression. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.root\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">root</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ccs</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L478-L494","name":"Mathlib.Tactic.CC.CCState.mkEntryCore","line":478,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.mkEntryCore","doc":"Update the `CCState` by constructing and inserting a new `Entry`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.mkEntryCore\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">mkEntryCore</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ccs</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">interpreted </span><span class=\"fn\">constructor</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L474-L474","name":"Mathlib.Tactic.CC.instInhabitedCCState","line":474,"kind":"instance","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instInhabitedCCState","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instInhabitedCCState\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">instInhabitedCCState</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L473-L473","name":"Mathlib.Tactic.CC.CCState.gmt","line":473,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.gmt","doc":"\"Global Modification Time\". gmt is a number stored on the `CCState`,\nit is compared with the modification time of a cc_entry in e-matching. See `CCState.mt`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.gmt\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">gmt</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L470-L470","name":"Mathlib.Tactic.CC.CCState.inconsistent","line":470,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.inconsistent","doc":"Returns true if the `CCState` is inconsistent. For example if it had both `a = b` and `a ≠ b`\nin it. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.inconsistent\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">inconsistent</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L467-L467","name":"Mathlib.Tactic.CC.CCState.acR","line":467,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.acR","doc":"Records equality between `ACApps`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.acR\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">acR</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACAppsMap\">ACAppsMap</a> (<a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">ACApps</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">DelayedExpr</a>)</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L465-L465","name":"Mathlib.Tactic.CC.CCState.acEntries","line":465,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.acEntries","doc":"Extra `Entry` information used by the AC part of the tactic. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.acEntries\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">acEntries</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ExprMap\">ExprMap</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACEntry\">ACEntry</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L463-L463","name":"Mathlib.Tactic.CC.CCState.opInfo","line":463,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.opInfo","doc":"Whether the canonical operator is supported by AC. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.opInfo\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">opInfo</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ExprMap\">ExprMap</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L461-L461","name":"Mathlib.Tactic.CC.CCState.canOps","line":461,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.canOps","doc":"Mapping from operators occurring in terms and their canonical\nrepresentation in this module "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.canOps\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">canOps</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ExprMap\">ExprMap</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L458-L458","name":"Mathlib.Tactic.CC.CCState.frozePartitions","line":458,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.frozePartitions","doc":"The congruence closure module has a mode where the root of each equivalence class is marked as\nan interpreted/abstract value. Moreover, in this mode proof production is disabled.\nThis capability is useful for heuristic instantiation. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.frozePartitions\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">frozePartitions</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L454-L454","name":"Mathlib.Tactic.CC.CCState.instImplicitReprs","line":454,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.instImplicitReprs","doc":"Records which instances of the same class are defeq. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.instImplicitReprs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">instImplicitReprs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.InstImplicitReprs\">InstImplicitReprs</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L452-L452","name":"Mathlib.Tactic.CC.CCState.subsingletonReprs","line":452,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.subsingletonReprs","doc":"Stores the root representatives of subsingletons, this uses `FastSingleton` instead of\n`Subsingleton`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.subsingletonReprs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">subsingletonReprs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.SubsingletonReprs\">SubsingletonReprs</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L451-L451","name":"Mathlib.Tactic.CC.CCState.symmCongruences","line":451,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.symmCongruences","doc":"Maps each expression to a set of expressions it might be congruent to,\nvia the symmetrical relation. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.symmCongruences\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">symmCongruences</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.SymmCongruences\">SymmCongruences</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L448-L448","name":"Mathlib.Tactic.CC.CCState.congruences","line":448,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.congruences","doc":"Maps each expression to a set of expressions it might be congruent to. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.congruences\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">congruences</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Congruences\">Congruences</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L446-L446","name":"Mathlib.Tactic.CC.CCState.parents","line":446,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.parents","doc":"Maps an expression `e` to the expressions `e` occurs in. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.parents\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">parents</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Parents\">Parents</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L444-L444","name":"Mathlib.Tactic.CC.CCState.entries","line":444,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.entries","doc":"Maps known expressions to their equivalence class data. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.entries\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">entries</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entries\">Entries</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L442-L442","name":"Mathlib.Tactic.CC.CCState.mk","line":442,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.mk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">toCCConfig</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCConfig\">CCConfig</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">entries</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entries\">Entries</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">parents</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Parents\">Parents</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">congruences</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Congruences\">Congruences</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">symmCongruences</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.SymmCongruences\">SymmCongruences</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">subsingletonReprs</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.SubsingletonReprs\">SubsingletonReprs</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">instImplicitReprs</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.InstImplicitReprs\">InstImplicitReprs</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">frozePartitions</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">canOps</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ExprMap\">ExprMap</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">opInfo</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ExprMap\">ExprMap</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">acEntries</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ExprMap\">ExprMap</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACEntry\">ACEntry</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">acR</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACAppsMap\">ACAppsMap</a> (<a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">ACApps</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">DelayedExpr</a>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">inconsistent</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">gmt</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L442-L474","name":"Mathlib.Tactic.CC.CCState.toCCConfig","line":442,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.toCCConfig","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.toCCConfig\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">toCCConfig</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCConfig\">CCConfig</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L438-L474","name":"Mathlib.Tactic.CC.CCState","line":438,"kind":"structure","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState","doc":"Congruence closure state.\nThis may be considered to be a set of expressions and an equivalence class over this set.\nThe equivalence class is generated by the equational rules that are added to the `CCState` and\ncongruence, that is, if `a = b` then `f(a) = f(b)` and so on. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span></a></span><span class=\"decl_extends\">extends</span> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCConfig\">Mathlib.Tactic.CC.CCConfig</a><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L436-L436","name":"Mathlib.Tactic.CC.ACTodoEntry","line":436,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACTodoEntry","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACTodoEntry\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">ACTodoEntry</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L434-L434","name":"Mathlib.Tactic.CC.TodoEntry","line":434,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.TodoEntry","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.TodoEntry\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">TodoEntry</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L431-L432","name":"Mathlib.Tactic.CC.InstImplicitReprs","line":431,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.InstImplicitReprs","doc":"Stores the root representatives of `.instImplicit` arguments. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.InstImplicitReprs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">InstImplicitReprs</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L427-L429","name":"Mathlib.Tactic.CC.SubsingletonReprs","line":427,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.SubsingletonReprs","doc":"Stores the root representatives of subsingletons, this uses `FastSingleton` instead of\n`Subsingleton`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.SubsingletonReprs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">SubsingletonReprs</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L420-L425","name":"Mathlib.Tactic.CC.SymmCongruences","line":420,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.SymmCongruences","doc":"The symmetric variant of `Congruences`.\n\nThe `Name` identifies which relation the congruence is considered for.\nNote that this only works for two-argument relations: `ModEq n` and `ModEq m` are considered the\nsame. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.SymmCongruences\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">SymmCongruences</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L418-L418","name":"Mathlib.Tactic.CC.instHashableSymmCongruencesKey","line":418,"kind":"instance","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instHashableSymmCongruencesKey","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instHashableSymmCongruencesKey\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">instHashableSymmCongruencesKey</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Hashable\">Hashable</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.SymmCongruencesKey\">SymmCongruencesKey</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L418-L418","name":"Mathlib.Tactic.CC.instBEqSymmCongruencesKey","line":418,"kind":"instance","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instBEqSymmCongruencesKey","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instBEqSymmCongruencesKey\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">instBEqSymmCongruencesKey</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#BEq\">BEq</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.SymmCongruencesKey\">SymmCongruencesKey</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L417-L417","name":"Mathlib.Tactic.CC.SymmCongruencesKey.h₂","line":417,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.SymmCongruencesKey.h₂","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.SymmCongruencesKey.h₂\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">SymmCongruencesKey</span>.<span class=\"name\">h₂</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.SymmCongruencesKey\">SymmCongruencesKey</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L417-L417","name":"Mathlib.Tactic.CC.SymmCongruencesKey.h₁","line":417,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.SymmCongruencesKey.h₁","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.SymmCongruencesKey.h₁\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">SymmCongruencesKey</span>.<span class=\"name\">h₁</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.SymmCongruencesKey\">SymmCongruencesKey</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L416-L416","name":"Mathlib.Tactic.CC.SymmCongruencesKey.mk","line":416,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.SymmCongruencesKey.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.SymmCongruencesKey.mk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">SymmCongruencesKey</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h₁ </span><span class=\"fn\">h₂</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.SymmCongruencesKey\">SymmCongruencesKey</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L416-L418","name":"Mathlib.Tactic.CC.SymmCongruencesKey","line":416,"kind":"structure","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.SymmCongruencesKey","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.SymmCongruencesKey\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">SymmCongruencesKey</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L413-L414","name":"Mathlib.Tactic.CC.Congruences","line":413,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Congruences","doc":"Maps each expression (via `mkCongruenceKey`) to expressions it might be congruent to. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Congruences\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">Congruences</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L411-L411","name":"Mathlib.Tactic.CC.instHashableCongruencesKey","line":411,"kind":"instance","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instHashableCongruencesKey","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instHashableCongruencesKey\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">instHashableCongruencesKey</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Hashable\">Hashable</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CongruencesKey\">CongruencesKey</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L411-L411","name":"Mathlib.Tactic.CC.instBEqCongruencesKey","line":411,"kind":"instance","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instBEqCongruencesKey","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instBEqCongruencesKey\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">instBEqCongruencesKey</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#BEq\">BEq</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CongruencesKey\">CongruencesKey</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L409-L410","name":"Mathlib.Tactic.CC.CongruencesKey.ho","line":409,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CongruencesKey.ho","doc":"`fn` is Higher-Order. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CongruencesKey.ho\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CongruencesKey</span>.<span class=\"name\">ho</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">fn </span><span class=\"fn\">arg</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CongruencesKey\">CongruencesKey</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L407-L408","name":"Mathlib.Tactic.CC.CongruencesKey.fo","line":407,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CongruencesKey.fo","doc":"`fn` is First-Order: we do not consider all partial applications. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CongruencesKey.fo\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CongruencesKey</span>.<span class=\"name\">fo</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">fn</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">args</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CongruencesKey\">CongruencesKey</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L406-L411","name":"Mathlib.Tactic.CC.CongruencesKey","line":406,"kind":"inductive","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CongruencesKey","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CongruencesKey\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CongruencesKey</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L401-L404","name":"Mathlib.Tactic.CC.Parents","line":401,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Parents","doc":"Used to map an expression `e` to another expression that contains `e`.\n\nWhen `e` is normalized, its parents should also change. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Parents\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">Parents</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L398-L399","name":"Mathlib.Tactic.CC.ParentOccSet","line":398,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ParentOccSet","doc":"Red-black sets of `ParentOcc`s. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ParentOccSet\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">ParentOccSet</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L396-L396","name":"Mathlib.Tactic.CC.ParentOcc.symmTable","line":396,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ParentOcc.symmTable","doc":"If `symmTable` is true, then we should use the `symmCongruences`, otherwise `congruences`.\nRemark: this information is redundant, it can be inferred from `expr`. We use store it for\nperformance reasons. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ParentOcc.symmTable\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">ParentOcc</span>.<span class=\"name\">symmTable</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ParentOcc\">ParentOcc</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L392-L392","name":"Mathlib.Tactic.CC.ParentOcc.expr","line":392,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ParentOcc.expr","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ParentOcc.expr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">ParentOcc</span>.<span class=\"name\">expr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ParentOcc\">ParentOcc</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L391-L391","name":"Mathlib.Tactic.CC.ParentOcc.mk","line":391,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ParentOcc.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ParentOcc.mk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">ParentOcc</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">expr</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">symmTable</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ParentOcc\">ParentOcc</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L390-L396","name":"Mathlib.Tactic.CC.ParentOcc","line":390,"kind":"structure","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ParentOcc","doc":"Used to record when an expression processed by `cc` occurs in another expression. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ParentOcc\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">ParentOcc</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L385-L388","name":"Mathlib.Tactic.CC.ACEntry.ROccs","line":385,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACEntry.ROccs","doc":"Returns the occurrences of this entry in either the LHS or RHS. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACEntry.ROccs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">ACEntry</span>.<span class=\"name\">ROccs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ent</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACEntry\">ACEntry</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">inLHS</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACAppsSet\">ACAppsSet</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L383-L383","name":"Mathlib.Tactic.CC.instInhabitedACEntry","line":383,"kind":"instance","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instInhabitedACEntry","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instInhabitedACEntry\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">instInhabitedACEntry</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACEntry\">ACEntry</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L382-L382","name":"Mathlib.Tactic.CC.ACEntry.RRHSOccs","line":382,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACEntry.RRHSOccs","doc":"AC variables that occur on the **left** hand side of an equality which `e` occurs as the right\nhand side of in `CCState.acR`. Don't confuse. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACEntry.RRHSOccs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">ACEntry</span>.<span class=\"name\">RRHSOccs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACEntry\">ACEntry</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACAppsSet\">ACAppsSet</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L379-L379","name":"Mathlib.Tactic.CC.ACEntry.RLHSOccs","line":379,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACEntry.RLHSOccs","doc":"AC variables that occur on the left hand side of an equality which `e` occurs as the left hand\nside of in `CCState.acR`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACEntry.RLHSOccs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">ACEntry</span>.<span class=\"name\">RLHSOccs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACEntry\">ACEntry</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACAppsSet\">ACAppsSet</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L376-L376","name":"Mathlib.Tactic.CC.ACEntry.idx","line":376,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACEntry.idx","doc":"Natural number associated to an expression. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACEntry.idx\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">ACEntry</span>.<span class=\"name\">idx</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACEntry\">ACEntry</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L374-L374","name":"Mathlib.Tactic.CC.ACEntry.mk","line":374,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACEntry.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACEntry.mk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">ACEntry</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">idx</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">RLHSOccs </span><span class=\"fn\">RRHSOccs</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACAppsSet\">ACAppsSet</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACEntry\">ACEntry</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L372-L383","name":"Mathlib.Tactic.CC.ACEntry","line":372,"kind":"structure","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACEntry","doc":"Equivalence class data associated with an expression `e` used by AC congruence closure\nmodules. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACEntry\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">ACEntry</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L369-L370","name":"Mathlib.Tactic.CC.Entries","line":369,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entries","doc":"Stores equivalence class data associated with an expression `e`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entries\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">Entries</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L367-L367","name":"Mathlib.Tactic.CC.instInhabitedEntry","line":367,"kind":"instance","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instInhabitedEntry","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instInhabitedEntry\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">instInhabitedEntry</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry\">Entry</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L366-L366","name":"Mathlib.Tactic.CC.Entry.mt","line":366,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.mt","doc":"The field `mt` is used to implement the mod-time optimization introduce by the Simplify\ntheorem prover. The basic idea is to introduce a counter gmt that records the number of\nheuristic instantiation that have occurred in the current branch. It is incremented after each\nround of heuristic instantiation. The field `mt` records the last time any proper descendant\nof this entry was involved in a merge. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.mt\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">Entry</span>.<span class=\"name\">mt</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry\">Entry</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L360-L360","name":"Mathlib.Tactic.CC.Entry.size","line":360,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.size","doc":"number of elements in the equivalence class, it is meaningless if `e != root` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.size\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">Entry</span>.<span class=\"name\">size</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry\">Entry</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L358-L358","name":"Mathlib.Tactic.CC.Entry.fo","line":358,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.fo","doc":"If `fo == true`, then the expression associated with this entry is an application, and we are\nusing first-order approximation to encode it. That is, we ignore its partial applications. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.fo\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">Entry</span>.<span class=\"name\">fo</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry\">Entry</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L355-L355","name":"Mathlib.Tactic.CC.Entry.heqProofs","line":355,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.heqProofs","doc":"`heqProofs == true` iff some proofs in the equivalence class are based on heterogeneous\nequality. We represent equality and heterogeneous equality in a single equivalence class. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.heqProofs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">Entry</span>.<span class=\"name\">heqProofs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry\">Entry</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L352-L352","name":"Mathlib.Tactic.CC.Entry.hasLambdas","line":352,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.hasLambdas","doc":"`true` if equivalence class contains lambda expressions "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.hasLambdas\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">Entry</span>.<span class=\"name\">hasLambdas</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry\">Entry</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L350-L350","name":"Mathlib.Tactic.CC.Entry.constructor","line":350,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.constructor","doc":"`true` if head symbol is a constructor "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.constructor\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">Entry</span>.<span class=\"name\">constructor</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry\">Entry</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L348-L348","name":"Mathlib.Tactic.CC.Entry.interpreted","line":348,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.interpreted","doc":"`true` if the node should be viewed as an abstract value "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.interpreted\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">Entry</span>.<span class=\"name\">interpreted</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry\">Entry</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L346-L346","name":"Mathlib.Tactic.CC.Entry.flipped","line":346,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.flipped","doc":"proof has been flipped "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.flipped\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">Entry</span>.<span class=\"name\">flipped</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry\">Entry</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L344-L344","name":"Mathlib.Tactic.CC.Entry.acVar","line":344,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.acVar","doc":"Variable in the AC theory. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.acVar\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">Entry</span>.<span class=\"name\">acVar</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry\">Entry</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L342-L342","name":"Mathlib.Tactic.CC.Entry.proof","line":342,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.proof","doc":"When `e` was added to this equivalence class because of an equality `(H : e = tgt)`, then\nwe store `tgt` at `target`, and `H` at `proof`. Both fields are none if `e == root` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.proof\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">Entry</span>.<span class=\"name\">proof</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry\">Entry</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr\">EntryExpr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L339-L339","name":"Mathlib.Tactic.CC.Entry.target","line":339,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.target","doc":"When `e` was added to this equivalence class because of an equality `(H : e = tgt)`, then\nwe store `tgt` at `target`, and `H` at `proof`. Both fields are none if `e == root` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.target\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">Entry</span>.<span class=\"name\">target</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry\">Entry</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L336-L336","name":"Mathlib.Tactic.CC.Entry.cgRoot","line":336,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.cgRoot","doc":"root of the congruence class, it is meaningless if `e` is not an application. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.cgRoot\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">Entry</span>.<span class=\"name\">cgRoot</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry\">Entry</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L334-L334","name":"Mathlib.Tactic.CC.Entry.root","line":334,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.root","doc":"root (aka canonical) representative of the equivalence class. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.root\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">Entry</span>.<span class=\"name\">root</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry\">Entry</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L332-L332","name":"Mathlib.Tactic.CC.Entry.next","line":332,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.next","doc":"next element in the equivalence class. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.next\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">Entry</span>.<span class=\"name\">next</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry\">Entry</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L330-L330","name":"Mathlib.Tactic.CC.Entry.mk","line":330,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.mk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">Entry</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">next </span><span class=\"fn\">root </span><span class=\"fn\">cgRoot</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">target</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">proof</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr\">EntryExpr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">acVar</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">flipped </span><span class=\"fn\">interpreted </span><span class=\"fn\">constructor </span><span class=\"fn\">hasLambdas </span><span class=\"fn\">heqProofs </span><span class=\"fn\">fo</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">size </span><span class=\"fn\">mt</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry\">Entry</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L329-L367","name":"Mathlib.Tactic.CC.Entry","line":329,"kind":"structure","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry","doc":"Equivalence class data associated with an expression `e`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">Entry</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L326-L326","name":"Mathlib.Tactic.CC.instCoeExprEntryExpr","line":326,"kind":"instance","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instCoeExprEntryExpr","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instCoeExprEntryExpr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">instCoeExprEntryExpr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Coe.html#Coe\">Coe</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr\">EntryExpr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L318-L324","name":"Mathlib.Tactic.CC.instToMessageDataEntryExpr","line":318,"kind":"instance","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instToMessageDataEntryExpr","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instToMessageDataEntryExpr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">instToMessageDataEntryExpr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Message.html#Lean.ToMessageData\">Lean.ToMessageData</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr\">EntryExpr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L316-L316","name":"Mathlib.Tactic.CC.instInhabitedEntryExpr","line":316,"kind":"instance","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instInhabitedEntryExpr","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instInhabitedEntryExpr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">instInhabitedEntryExpr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr\">EntryExpr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L314-L315","name":"Mathlib.Tactic.CC.EntryExpr.ofDExpr","line":314,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr.ofDExpr","doc":"An `EntryExpr` of a `DelayedExpr`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr.ofDExpr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">EntryExpr</span>.<span class=\"name\">ofDExpr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">DelayedExpr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr\">EntryExpr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L312-L313","name":"Mathlib.Tactic.CC.EntryExpr.refl","line":312,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr.refl","doc":"dummy refl proof, it is just a placeholder. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr.refl\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">EntryExpr</span>.<span class=\"name\">refl</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr\">EntryExpr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L310-L311","name":"Mathlib.Tactic.CC.EntryExpr.eqTrue","line":310,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr.eqTrue","doc":"dummy eq_true proof, it is just a placeholder "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr.eqTrue\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">EntryExpr</span>.<span class=\"name\">eqTrue</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr\">EntryExpr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L308-L309","name":"Mathlib.Tactic.CC.EntryExpr.congr","line":308,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr.congr","doc":"dummy congruence proof, it is just a placeholder. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr.congr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">EntryExpr</span>.<span class=\"name\">congr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr\">EntryExpr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L306-L307","name":"Mathlib.Tactic.CC.EntryExpr.ofExpr","line":306,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr.ofExpr","doc":"An `EntryExpr` of just an `Expr`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr.ofExpr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">EntryExpr</span>.<span class=\"name\">ofExpr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr\">EntryExpr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L304-L316","name":"Mathlib.Tactic.CC.EntryExpr","line":304,"kind":"inductive","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr","doc":"This is used as a proof term in `Entry`s instead of `Expr`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">EntryExpr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L301-L301","name":"Mathlib.Tactic.CC.instCoeExprDelayedExpr","line":301,"kind":"instance","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instCoeExprDelayedExpr","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instCoeExprDelayedExpr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">instCoeExprDelayedExpr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Coe.html#Coe\">Coe</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">DelayedExpr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L299-L299","name":"Mathlib.Tactic.CC.instInhabitedDelayedExpr","line":299,"kind":"instance","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instInhabitedDelayedExpr","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instInhabitedDelayedExpr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">instInhabitedDelayedExpr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">DelayedExpr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L297-L298","name":"Mathlib.Tactic.CC.DelayedExpr.heqSymm","line":297,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr.heqSymm","doc":"Will be applied to `HEq.symm`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr.heqSymm\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">DelayedExpr</span>.<span class=\"name\">heqSymm</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">DelayedExpr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">DelayedExpr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L295-L296","name":"Mathlib.Tactic.CC.DelayedExpr.heqOfEq","line":295,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr.heqOfEq","doc":"Will be applied to `heq_of_eq`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr.heqOfEq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">DelayedExpr</span>.<span class=\"name\">heqOfEq</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">DelayedExpr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">DelayedExpr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L293-L294","name":"Mathlib.Tactic.CC.DelayedExpr.eqTransOpt","line":293,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr.eqTransOpt","doc":"Will be applied to `Eq.trans`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr.eqTransOpt\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">DelayedExpr</span>.<span class=\"name\">eqTransOpt</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a₁ </span><span class=\"fn\">a₂ </span><span class=\"fn\">a₃</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">ACApps</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h₁ </span><span class=\"fn\">h₂</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">DelayedExpr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">DelayedExpr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L291-L292","name":"Mathlib.Tactic.CC.DelayedExpr.eqTrans","line":291,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr.eqTrans","doc":"Will be applied to `Eq.trans`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr.eqTrans\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">DelayedExpr</span>.<span class=\"name\">eqTrans</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h₁ </span><span class=\"fn\">h₂</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">DelayedExpr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">DelayedExpr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L289-L290","name":"Mathlib.Tactic.CC.DelayedExpr.eqSymmOpt","line":289,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr.eqSymmOpt","doc":"Will be applied to `Eq.symm`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr.eqSymmOpt\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">DelayedExpr</span>.<span class=\"name\">eqSymmOpt</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a₁ </span><span class=\"fn\">a₂</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">ACApps</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">DelayedExpr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">DelayedExpr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L287-L288","name":"Mathlib.Tactic.CC.DelayedExpr.eqSymm","line":287,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr.eqSymm","doc":"Will be applied to `Eq.symm`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr.eqSymm\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">DelayedExpr</span>.<span class=\"name\">eqSymm</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">DelayedExpr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">DelayedExpr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L285-L286","name":"Mathlib.Tactic.CC.DelayedExpr.congrFun","line":285,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr.congrFun","doc":"Will be applied to `congr_fun`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr.congrFun\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">DelayedExpr</span>.<span class=\"name\">congrFun</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">DelayedExpr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">ACApps</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">DelayedExpr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L283-L284","name":"Mathlib.Tactic.CC.DelayedExpr.congrArg","line":283,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr.congrArg","doc":"Will be applied to `congr_arg`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr.congrArg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">DelayedExpr</span>.<span class=\"name\">congrArg</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">DelayedExpr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">DelayedExpr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L280-L282","name":"Mathlib.Tactic.CC.DelayedExpr.eqProof","line":280,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr.eqProof","doc":"A placeholder as an equality proof between given two terms which will be generated by non-AC\ncongruence closure modules later. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr.eqProof\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">DelayedExpr</span>.<span class=\"name\">eqProof</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">lhs </span><span class=\"fn\">rhs</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">DelayedExpr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L278-L279","name":"Mathlib.Tactic.CC.DelayedExpr.ofExpr","line":278,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr.ofExpr","doc":"A `DelayedExpr` of just an `Expr`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr.ofExpr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">DelayedExpr</span>.<span class=\"name\">ofExpr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">DelayedExpr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L274-L299","name":"Mathlib.Tactic.CC.DelayedExpr","line":274,"kind":"inductive","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr","doc":"For proof terms generated by AC congruence closure modules, we want a placeholder as an equality\nproof between given two terms which will be generated by non-AC congruence closure modules later.\n`DelayedExpr` represents it using `eqProof`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">DelayedExpr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L267-L272","name":"Mathlib.Tactic.CC.ACAppsSet","line":267,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACAppsSet","doc":"Red-black sets of `ACApps`es.\n\nTODO: the choice between `TreeSet` and `HashSet` is not obvious:\nonce the `cc` tactic is used a lot in Mathlib, we should profile and see\nif `HashSet` could be more optimal. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACAppsSet\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">ACAppsSet</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L260-L265","name":"Mathlib.Tactic.CC.ACAppsMap","line":260,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACAppsMap","doc":"Red-black maps whose keys are `ACApps`es.\n\nTODO: the choice between `TreeMap` and `HashMap` is not obvious:\nonce the `cc` tactic is used a lot in Mathlib, we should profile and see\nif `HashMap` could be more optimal. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACAppsMap\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">ACAppsMap</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a> u</div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L254-L258","name":"Mathlib.Tactic.CC.ACApps.toExpr","line":254,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps.toExpr","doc":"Converts an `ACApps` to an `Expr`. This returns `none` when the empty applications are given. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps.toExpr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">ACApps</span>.<span class=\"name\">toExpr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">ACApps</a> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L246-L252","name":"Mathlib.Tactic.CC.ACApps.mkFlatApps","line":246,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps.mkFlatApps","doc":"Flattens given two `ACApps`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps.mkFlatApps\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">ACApps</span>.<span class=\"name\">mkFlatApps</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">op</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e₁ </span><span class=\"fn\">e₂</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">ACApps</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">ACApps</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L242-L244","name":"Mathlib.Tactic.CC.ACApps.mkApps","line":242,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps.mkApps","doc":"Sorts `args` and applies them to `ACApps.apps`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps.mkApps\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">ACApps</span>.<span class=\"name\">mkApps</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">op</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">args</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">ACApps</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L223-L240","name":"Mathlib.Tactic.CC.ACApps.intersection","line":223,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps.intersection","doc":"Appends elements in the intersection of `e₁` and `e₂` to `r`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps.intersection\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">ACApps</span>.<span class=\"name\">intersection</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e₁ </span><span class=\"fn\">e₂</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">ACApps</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">r</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> := <a href=\"./Init/Prelude.html#List.toArray\">#[</a><a href=\"./Init/Prelude.html#List.toArray\">]</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L215-L221","name":"Mathlib.Tactic.CC.ACApps.append","line":215,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps.append","doc":"Appends arguments of `e` to `r`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps.append\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">ACApps</span>.<span class=\"name\">append</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">op</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">ACApps</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">r</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> := <a href=\"./Init/Prelude.html#List.toArray\">#[</a><a href=\"./Init/Prelude.html#List.toArray\">]</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L185-L213","name":"Mathlib.Tactic.CC.ACApps.diff","line":185,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps.diff","doc":"Appends elements of the set difference `e₁ \\ e₂` to `r`.\nExample: given `e₁ := a*a*a*a*b*b*c*d*d*d` and `e₂ := a*a*a*b*b*d`,\nthe result is `#[a, c, d, d]`\n\nPrecondition: `e₂.isSubset e₁` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps.diff\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">ACApps</span>.<span class=\"name\">diff</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e₁ </span><span class=\"fn\">e₂</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">ACApps</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">r</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> := <a href=\"./Init/Prelude.html#List.toArray\">#[</a><a href=\"./Init/Prelude.html#List.toArray\">]</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L161-L183","name":"Mathlib.Tactic.CC.ACApps.isSubset","line":161,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps.isSubset","doc":"Return true iff `e₁` is a \"subset\" of `e₂`.\n\nExample: The result is `true` for `e₁ := a*a*a*b*d` and `e₂ := a*a*a*a*b*b*c*d*d`.\nThe result is also `true` for `e₁ := a` and `e₂ := a*a*a*b*c`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps.isSubset\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">ACApps</span>.<span class=\"name\">isSubset</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e₁ </span><span class=\"fn\">e₂</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">ACApps</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L146-L159","name":"Mathlib.Tactic.CC.instOrdACApps","line":146,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instOrdACApps","doc":"Ordering on `ACApps` sorts `.ofExpr` before `.apps`, and sorts `.apps` by function symbol,\nthen by shortlex order. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instOrdACApps\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">instOrdACApps</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Ord.html#Ord\">Ord</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">ACApps</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L143-L143","name":"Mathlib.Tactic.CC.instCoeExprACApps","line":143,"kind":"instance","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instCoeExprACApps","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instCoeExprACApps\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">instCoeExprACApps</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Coe.html#Coe\">Coe</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">ACApps</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L141-L141","name":"Mathlib.Tactic.CC.instBEqACApps","line":141,"kind":"instance","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instBEqACApps","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instBEqACApps\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">instBEqACApps</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#BEq\">BEq</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">ACApps</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L141-L141","name":"Mathlib.Tactic.CC.instInhabitedACApps","line":141,"kind":"instance","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instInhabitedACApps","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instInhabitedACApps\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">instInhabitedACApps</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">ACApps</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L137-L140","name":"Mathlib.Tactic.CC.ACApps.apps","line":137,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps.apps","doc":"An `ACApps` of applications of a binary operator. `args` are assumed to be sorted.\n\nSee also `ACApps.mkApps` if `args` are not yet sorted. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps.apps\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">ACApps</span>.<span class=\"name\">apps</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">op</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">args</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">ACApps</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L135-L136","name":"Mathlib.Tactic.CC.ACApps.ofExpr","line":135,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps.ofExpr","doc":"An `ACApps` of just an `Expr`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps.ofExpr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">ACApps</span>.<span class=\"name\">ofExpr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">ACApps</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L132-L141","name":"Mathlib.Tactic.CC.ACApps","line":132,"kind":"inductive","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps","doc":"An `ACApps` represents either just an `Expr` or applications of an associative and commutative\nbinary operator. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">ACApps</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L130-L130","name":"Mathlib.Tactic.CC.instInhabitedCCConfig","line":130,"kind":"instance","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instInhabitedCCConfig","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instInhabitedCCConfig\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">instInhabitedCCConfig</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCConfig\">CCConfig</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L129-L129","name":"Mathlib.Tactic.CC.CCConfig.values","line":129,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCConfig.values","doc":"If `true`, we treat values as atomic symbols "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCConfig.values\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCConfig</span>.<span class=\"name\">values</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCConfig\">CCConfig</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L127-L127","name":"Mathlib.Tactic.CC.CCConfig.em","line":127,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCConfig.em","doc":"If `true`, then use excluded middle "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCConfig.em\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCConfig</span>.<span class=\"name\">em</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCConfig\">CCConfig</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L125-L125","name":"Mathlib.Tactic.CC.CCConfig.hoFns","line":125,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCConfig.hoFns","doc":"If `hoFns` is `some fns`, then full (and more expensive) support for higher-order functions is\n*only* considered for the functions in fns and local functions. The performance overhead is\ndescribed in the paper \"Congruence Closure in Intensional Type Theory\". If `hoFns` is `none`,\nthen full support is provided for *all* constants. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCConfig.hoFns\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCConfig</span>.<span class=\"name\">hoFns</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCConfig\">CCConfig</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L120-L120","name":"Mathlib.Tactic.CC.CCConfig.ac","line":120,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCConfig.ac","doc":"If `true`, congruence closure modulo Associativity and Commutativity. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCConfig.ac\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCConfig</span>.<span class=\"name\">ac</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCConfig\">CCConfig</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L118-L118","name":"Mathlib.Tactic.CC.CCConfig.ignoreInstances","line":118,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCConfig.ignoreInstances","doc":"If `true`, congruence closure will treat implicit instance arguments as constants.\n\nThis means that setting `ignoreInstances := false` will fail to unify two definitionally equal\ninstances of the same class. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCConfig.ignoreInstances\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCConfig</span>.<span class=\"name\">ignoreInstances</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCConfig\">CCConfig</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L113-L113","name":"Mathlib.Tactic.CC.CCConfig.mk","line":113,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCConfig.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCConfig.mk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCConfig</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ignoreInstances </span><span class=\"fn\">ac</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hoFns</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">em </span><span class=\"fn\">values</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCConfig\">CCConfig</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L112-L130","name":"Mathlib.Tactic.CC.CCConfig","line":112,"kind":"structure","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCConfig","doc":"Configs used in congruence closure modules. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCConfig\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCConfig</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L109-L110","name":"Mathlib.Tactic.CC.CCCongrTheoremCache","line":109,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheoremCache","doc":"Caches used to find corresponding `CCCongrTheorem`s. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheoremCache\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCCongrTheoremCache</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L107-L107","name":"Mathlib.Tactic.CC.instHashableCCCongrTheoremKey","line":107,"kind":"instance","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instHashableCCCongrTheoremKey","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instHashableCCCongrTheoremKey\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">instHashableCCCongrTheoremKey</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Hashable\">Hashable</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheoremKey\">CCCongrTheoremKey</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L107-L107","name":"Mathlib.Tactic.CC.instBEqCCCongrTheoremKey","line":107,"kind":"instance","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instBEqCCCongrTheoremKey","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instBEqCCCongrTheoremKey\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">instBEqCCCongrTheoremKey</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#BEq\">BEq</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheoremKey\">CCCongrTheoremKey</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L106-L106","name":"Mathlib.Tactic.CC.CCCongrTheoremKey.nargs","line":106,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheoremKey.nargs","doc":"The number of arguments of `fn`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheoremKey.nargs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCCongrTheoremKey</span>.<span class=\"name\">nargs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheoremKey\">CCCongrTheoremKey</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L104-L104","name":"Mathlib.Tactic.CC.CCCongrTheoremKey.fn","line":104,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheoremKey.fn","doc":"The function of the given `CCCongrTheorem`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheoremKey.fn\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCCongrTheoremKey</span>.<span class=\"name\">fn</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheoremKey\">CCCongrTheoremKey</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L102-L102","name":"Mathlib.Tactic.CC.CCCongrTheoremKey.mk","line":102,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheoremKey.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheoremKey.mk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCCongrTheoremKey</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">fn</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">nargs</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheoremKey\">CCCongrTheoremKey</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L101-L107","name":"Mathlib.Tactic.CC.CCCongrTheoremKey","line":101,"kind":"structure","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheoremKey","doc":"Keys used to find corresponding `CCCongrTheorem`s. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheoremKey\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCCongrTheoremKey</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L92-L99","name":"Mathlib.Tactic.CC.mkCCHCongrWithArity","line":92,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.mkCCHCongrWithArity","doc":"Automatically generated congruence lemma based on heterogeneous equality.\n\nThis returns an annotated version of the result from `Lean.Meta.mkHCongrWithArity`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.mkCCHCongrWithArity\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">mkCCHCongrWithArity</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">fn</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">nargs</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheorem\">CCCongrTheorem</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L90-L90","name":"Mathlib.Tactic.CC.CCCongrTheorem.hcongrTheorem","line":90,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheorem.hcongrTheorem","doc":"If `hcongrTheorem` is true, then lemma was created using `mkHCongrWithArity`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheorem.hcongrTheorem\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCCongrTheorem</span>.<span class=\"name\">hcongrTheorem</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheorem\">CCCongrTheorem</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L88-L88","name":"Mathlib.Tactic.CC.CCCongrTheorem.heqResult","line":88,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheorem.heqResult","doc":"If `heqResult` is true, then lemma is based on heterogeneous equality\nand the conclusion is a heterogeneous equality. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheorem.heqResult\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCCongrTheorem</span>.<span class=\"name\">heqResult</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheorem\">CCCongrTheorem</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L85-L85","name":"Mathlib.Tactic.CC.CCCongrTheorem.mk","line":85,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheorem.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheorem.mk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCCongrTheorem</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">toCongrTheorem</span> : <a href=\"./Lean/Meta/CongrTheorems.html#Lean.Meta.CongrTheorem\">Lean.Meta.CongrTheorem</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">heqResult </span><span class=\"fn\">hcongrTheorem</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheorem\">CCCongrTheorem</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L85-L90","name":"Mathlib.Tactic.CC.CCCongrTheorem.toCongrTheorem","line":85,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheorem.toCongrTheorem","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheorem.toCongrTheorem\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCCongrTheorem</span>.<span class=\"name\">toCongrTheorem</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheorem\">CCCongrTheorem</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/CongrTheorems.html#Lean.Meta.CongrTheorem\">Lean.Meta.CongrTheorem</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L84-L90","name":"Mathlib.Tactic.CC.CCCongrTheorem","line":84,"kind":"structure","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheorem","doc":"`CongrTheorem`s equipped with additional infos used by congruence closure modules. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheorem\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCCongrTheorem</span></a></span><span class=\"decl_extends\">extends</span> <a href=\"./Lean/Meta/CongrTheorems.html#Lean.Meta.CongrTheorem\">Lean.Meta.CongrTheorem</a><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L77-L82","name":"Mathlib.Tactic.CC.ExprSet","line":77,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ExprSet","doc":"Red-black sets of `Expr`s.\n\nTODO: the choice between `TreeSet` and `HashSet` is not obvious:\nonce the `cc` tactic is used a lot in Mathlib, we should profile and see\nif `HashSet` could be more optimal. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ExprSet\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">ExprSet</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L70-L75","name":"Mathlib.Tactic.CC.ExprMap","line":70,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ExprMap","doc":"Red-black maps whose keys are `Expr`s.\n\nTODO: the choice between `TreeMap` and `HashMap` is not obvious:\nonce the `cc` tactic is used a lot in Mathlib, we should profile and see\nif `HashMap` could be more optimal. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ExprMap\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">ExprMap</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a> u</div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L66-L68","name":"Mathlib.Tactic.CC.instOrdExpr_mathlib","line":66,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instOrdExpr_mathlib","doc":"Ordering on `Expr`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instOrdExpr_mathlib\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">instOrdExpr_mathlib</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Ord.html#Ord\">Ord</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L45-L64","name":"Mathlib.Tactic.CC.liftFromEq","line":45,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.liftFromEq","doc":"Given a reflexive relation `R`, and a proof `H : a = b`, build a proof for `R a b` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.liftFromEq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">liftFromEq</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">R</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">H</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L32-L43","name":"Mathlib.Tactic.CC.isInterpretedValue","line":32,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.isInterpretedValue","doc":"Return true if `e` represents a value (nat/int numeral, character, or string).\n\nIn addition to the conditions in `Mathlib.Tactic.CC.isValue`, this also checks that\nkernel computation can compare the values for equality. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.isInterpretedValue\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">isInterpretedValue</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/e9db98beeec1b415e419a3a8f0d96ed55b0f29ab/Mathlib/Tactic/CC/Datatypes.lean#L28-L30","name":"Mathlib.Tactic.CC.isValue","line":28,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.isValue","doc":"Return true if `e` represents a constant value (numeral, character, or string). "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.isValue\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">isValue</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"}]}